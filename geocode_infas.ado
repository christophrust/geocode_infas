*! ado for retrieving the geo code corresponding to an address from PAGSCoder (Infas360, infoware)
*! christoph.rust@wiwi.uni-regensburg.de
*! last modified: 19.02.2019



/*cap program drop geocode_infas

program define geocode_infas
version 14
// version 14 because of mlib is compiled with stata 14


end
*/


// clear mata

// cap program drop geocode_infas
// 

program define geocode_infas 


syntax , street(varname) strnum(varname) plz(varname) city(varname) [ nclient(real 2) addressreturn  multihit servaddr(string) idvar(string) port(string) encoding(string) nocleanup timeout(real 2)]


if "`port'" =="" local port="8080"

if "`servaddr'"=="" local servaddr = "PAGSCoder"

if "`multihit'"!="" {
	if "`idvar'"==""{
		di as err "Please specify also an ID variable"
		exit
		}
	*di "option multihit still not supported"
	*local multihit = ""
	}

if "`encoding'"=="" local encoding = "utf8"

** parallelize
*exit 
if "`addressreturn'"!="" local addressreturn=1
else local addressreturn=0

cap mkdir geocode_tempfiles

qui count
local N = r(N)

local parts=`nclient'
if `parts'>1 {
	/* distributed computing */
	/* write do files and partition dataset, the last partition will be for us */
	di as txt "Writing do-files:" _continue


	local l=1
	while `l'<`parts' {
		/* write do file */
		qui file open dofile using geocode_tempfiles/temp_instance`l'.do , write replace
		file write dofile "* do file generated by geocode_infas" _n _n
		file write dofile `"global S_ADO = `"$S_ADO"'"' _n _n
		file write dofile `"adopath + "`c(pwd)'" "' _n
		file write dofile "capture noi{" _n
		file write dofile "set timeout1 `timeout'" _n
		file write dofile "use temp_package_tocode`l'" _n _n
		file write dofile "di c(current_time)" _n _n
		if "`multihit'"=="" {
			file write dofile `"mata: main_infas_geocode("`street'" , "`strnum'"  , "`city'" , "`plz'" , `addressreturn' , "PAGSCoder`l'" , "`port'" , "`encoding'")"' _n
		}
		else {
			file write dofile `"mata: main_infas_geocode_multiple("`idvar'" , "`street'" , "`strnum'"  , "`city'" , "`plz'" , `addressreturn' , "PAGSCoder`l'" , "`port'", "`encoding'")"' _n
		}
		file write dofile "di c(current_time)" _n _n
		file write dofile "}" _n
		file write dofile "if _rc {" _n
		file write dofile "cap confirm var return_code" _n
		file write dofile "if _rc gen return_code=3" _n
		file write dofile "else replace return_code = 3 if return_code==." _n
		file write dofile "}" _n
		file write dofile "save temp_package_coded`l' , replace" _n _n
		file close dofile
		local ++l
		}
	di as res "{col 25}done!"
	di as txt "Partitioning datasets:" _continue


	local partsize = int(`N'/`parts')
	forvalues l=1/`parts' {
		local u = `l'*`partsize'
		if `l'==`parts' local u=`N'
		local d = (`l'-1)*`partsize'+1
		preserve
		qui keep in `d'/`u'
		qui save geocode_tempfiles/temp_package_tocode`l' , replace
		restore
		}

	di as res "{col 25}done!"
	}

/* start calculation */
/* find out how stata executable is called */
if c(os)=="Windows" {
	local flavor = c(flavor)
	local bit = c(bit)
	if "`flavor'"!="IC" local exename smStata
	else {
		if c(MP)==1 local exename StataMP
		else if c(SE)==1 local exename StataSE
		else if c(SE)==0 local exename Stata
		}
	if `bit' == 32 local bit
	else local bit -64
	local stata_executable = "`c(sysdir_stata)'`exename'" + "`bit'.exe"
	}
else {
	if c(MP) local exename stata-mp
	else if c(SE) local exename stata-se
	else if c(flavor) == "Small" local exename stata-sm
	else if c(flavor) == "IC" local exename stata
	local stata_executable = "`c(sysdir_stata)'`exename'"
	}
	*di "`stata_executable'"

local tmpdir = c(tmpdir)
if c(os)=="Windows" {
	if substr("`tmpdir'",-1,.)=="/" {
		local tmpdir = substr("`tmpdir'",1,length("`tmpdir'")-1)+"\"
		}
	if substr("`tmpdir'",-1,.)!="\" {
		local tmpdir = "`tmpdir'" + "\"
		}
	}
// else if c(os)=="Unix" {
else {
	if substr("`tmpdir'",-1,.)!="/" {
		local tmpdir = "`tmpdir'" + "/"
		}
	}
* di "`tmpdir'"
local pwdir = subinstr("`c(pwd)'"," ","\ ",.)

if c(os)=="Windows" {
	qui file open bat using geocode_tempfiles/__tmp_geocode.bat , write replace
	file write bat "pushd `c(pwd)'\geocode_tempfiles" _n
	file write bat "del temp_package_coded*" _n
	file write bat "del temp_instance*.log" _n
	local l=1
	while `l'<`parts' {
		local tmpdir`l' = "`tmpdir'" + "_osrm12tmpdir00`l'"
		cap erase temp_package_routed`l'
		file write bat "mkdir `tmpdir`l''" _n
		file write bat `"start /MIN /HIGH set STATATMP=`tmpdir`l'' ^& "`stata_executable'" /e /q do temp_instance`l'.do ^&exit"' _n
		local ++l
		}
	file write bat "popd" _n
	file write bat "exit" _n
	file close bat
	/* start subroutines */
	winexec `c(pwd)'/geocode_tempfiles/__tmp_geocode.bat
	}
else if c(os)=="Unix" {
	file open shell using geocode_tempfiles/__tmp_geocode.sh , write replace
	file write shell "cd `pwdir'/geocode_tempfiles" _n
	file write shell "rm temp_package_coded*" _n
	local l=1
	while `l'<`parts' {
		local tmpdir`l' = "`tmpdir'" + "_osrm12tmpdir00`l'"
		cap erase temp_package_routed`l'
		file write shell "mkdir -p `tmpdir`l''" _n
		file write shell "export STATATMP=`tmpdir`l''" _n
		file write shell `"`stata_executable' -b -q do temp_instance`l'.do &"' _n
		local ++l
		}
	file write shell "cd `pwdir'" _n
	file close shell 
	/* start subroutines */
	shell chmod +x `pwdir'/geocode_tempfiles/__tmp_geocode.sh
	winexec `pwdir'/geocode_tempfiles/__tmp_geocode.sh
	}

di as txt "Geocoding using PAGSCoder (Infas360):"
//if "`adopath'" !="" adopath ++ `adopath'
// local srvnum = int((`l'-1)/`threads')+1
// di `srvnum'
if "`verbose'"!="" local progress

if `parts' > 1{
	use geocode_tempfiles/temp_package_tocode`l' , clear
	}

di ""
di "Start:"
di c(current_date)
di c(current_time)
if "`multihit'"=="" {
	// di "test"
	mata: main_infas_geocode("`street'" , "`strnum'"  , "`city'" , "`plz'" , `addressreturn' , "`servaddr'", "`port'", "`encoding'")
}
else {
	mata: main_infas_geocode_multiple("`idvar'" , "`street'" , "`strnum'"  , "`city'" , "`plz'" , `addressreturn' , "`servaddr'", "`port'", "`encoding'")
}
di ""
di "Main instance finished:"
di c(current_time)
di c(current_date)
di "Waiting for parallel sessions to finish..."

if `parts' > 1 {
	qui save geocode_tempfiles/temp_package_coded`l' , replace

	/* collecting datasets when finished */

	/*
	local bool=1
	while `bool' {
		local sum = 0
		forvalues l=1/`parts'{
			cap confirm file geocode_tempfiles/temp_package_coded`l'.dta
			if !_rc local ++sum
			}
		if `sum'==`parts' local bool=0
		else sleep 1000
		}
	*/
	local bool=1
	while `bool' {
		/* check each log file for last line = "end of do-file" */
		local sum=0
		local nPar = `parts'-1
		forvalues l=1/`nPar' {
			check_end_dofile using geocode_tempfiles/temp_instance`l'.log
			if r(rc)==0 local ++sum
			}
		if `sum'==`nPar' local bool=0
		else sleep 1000
		}
	* even if files are there, they not are necessarily entirely written on disk
	
	cap use geocode_tempfiles/temp_package_coded1 , clear
	
	local cnt=0
	while (_rc & `cnt'<4) {
		sleep 5000
		cap use geocode_tempfiles/temp_package_coded1 , clear
		local cnt = `cnt'+1
		}
	if `cnt' ==4 {
		di as err "Could not open temporary file, check log"
		exit
		}
	forvalues l=2/`parts' {
		append using geocode_tempfiles/temp_package_coded`l'
		}
	}

di "Finished:"
di c(current_time)
di c(current_date)

label define ret_codeLab 0 "OK" 1 "No Hit" 2 "Geocoder reported an error" 3 "Error connecting to Server" , modify
label values ret_code ret_codeLab 

* remove temporary files
if "`cleanup'"==""{
    shell rmdir /S /Q geocode_tempfiles
    }
	
end





cap program drop check_end_dofile
program define check_end_dofile , rclass
syntax using

// di `"`using'"'
cap file open my_logfile `using' , read text
if !_rc {
	file read my_logfile txtfile
	while r(eof)==0 {
		file read my_logfile line
		local txtfile `txtfile' `line'
		}
	file close my_logfile
	// di `"`txtfile'"'
	if regexm(`"`txtfile'"' , "file temp_package_coded.*dta saved") local rc = 0
	else local rc = 1
	}
else local rc = 2
*di "`rc'"
return scalar rc = `rc'
end


